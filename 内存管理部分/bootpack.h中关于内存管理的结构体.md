在 `bootpack.h` 中，内存管理相关的核心结构体定义如下：

---

### 1. **`FREEINFO`（空闲内存块信息）**
```c
struct FREEINFO {    /* 空闲内存块信息 */
    unsigned int addr, size; // addr: 起始地址, size: 块大小（字节）
};
```
- **功能**：描述一个**连续的空闲内存区域**。
- **字段说明**：
  - `addr`：空闲内存块的起始物理地址。
  - `size`：空闲内存块的长度（以字节为单位）。
- **作用**：作为内存管理的基本单元，用于记录系统中每一块可用的空闲内存区域。

---

### 2. **`MEMMAN`（内存管理器）**
```c
struct MEMMAN {      /* 内存管理器 */
    int frees;       // 当前空闲块数量
    int maxfrees;    // 历史最大空闲块数（用于监控碎片化）
    int lostsize;    // 因碎片化丢失的内存总量
    int losts;       // 内存释放失败的次数
    struct FREEINFO free[MEMMAN_FREES]; // 空闲块数组（最大 MEMMAN_FREES 个）
};
```
- **功能**：全局内存管理器的核心数据结构，负责**跟踪所有空闲内存块**。
- **字段说明**：
  - `frees`：当前系统中存在的空闲内存块数量。
  - `maxfrees`：运行过程中达到的最大空闲块数（帮助评估内存碎片化程度）。
  - `lostsize`：因无法合并相邻块而丢失的内存总量（碎片化的量化指标）。
  - `losts`：内存释放失败的次数（通常因空闲块数组满导致）。
  - `free[MEMMAN_FREES]`：存储所有空闲块的数组，最大容量为 `MEMMAN_FREES`（4090）。
- **作用**：
  - 通过**首次适应算法**（遍历数组找到第一个足够大的块）分配内存。
  - 在释放内存时尝试**合并相邻空闲块**，减少碎片。
  - 统计内存使用情况，帮助调试和优化。

---

### 关键宏定义
```c
#define MEMMAN_FREES    4090    // 空闲块数组的最大容量（约占用 32KB 内存）
#define MEMMAN_ADDR     0x003c0000 // 内存管理器自身的固定存储地址
```
- **设计意图**：
  - `MEMMAN_FREES`：限制空闲块数量，避免无限增长（简单但可能限制大规模内存管理）。
  - `MEMMAN_ADDR`：将内存管理器实例固定在物理地址 `0x003c0000`，确保系统启动时可访问。

---

### 内存管理函数（在 `memory.c` 实现）
```c
unsigned int memman_alloc(struct MEMMAN *man, unsigned int size);   // 分配内存
int memman_free(struct MEMMAN *man, unsigned int addr, unsigned int size);  // 释放内存
unsigned int memman_total(struct MEMMAN *man); // 计算总空闲内存
```
- **操作流程**：
  1. **分配**：遍历 `free` 数组，找到首个 `size >= 需求` 的块，分割后更新数组。
  2. **释放**：插入新释放的块到数组，检查前后相邻块并合并，减少碎片。
  3. **统计**：遍历数组累加所有 `free[i].size`，得到总可用内存。

---

### 设计特点
1. **数组式管理**：
   - 优点：实现简单，无需动态内存分配。
   - 缺点：最大空闲块数固定（4090），可能限制大规模内存管理。

2. **碎片处理**：
   - 通过合并相邻块减少外部碎片。
   - 通过 `lostsize` 和 `losts` 监控无法回收的内存。

3. **性能权衡**：
   - 首次适应算法的时间复杂度为 O(n)，适合小规模系统。
   - 4K 对齐分配（`memman_alloc_4k`）优化分页管理。

---

### 示例场景
假设系统有 3 个空闲块：
```c
free[0] = {addr: 0x1000, size: 0x2000}
free[1] = {addr: 0x4000, size: 0x1000}
free[2] = {addr: 0x6000, size: 0x3000}
```
- **分配 0x1500**：从 `free[0]` 分割，剩余 `addr: 0x2500, size: 0x0B00`。
- **释放 0x3000-0x4000**：插入到 `free[0]` 和 `free[1]` 之间，合并后形成 `addr:0x1000, size:0x4000`。

---

通过这种设计，`MEMMAN` 和 `FREEINFO` 共同实现了物理内存的动态管理，为操作系统的任务、图形界面等模块提供了基础内存分配能力。