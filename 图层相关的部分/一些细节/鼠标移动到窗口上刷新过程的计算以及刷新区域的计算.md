### **示例：鼠标移动到窗口上的刷新过程**

假设屏幕分辨率是 **320x200**，各图层属性如下：
- **背景图层**：全屏覆盖（320x200），高度为 `0`。
- **窗口图层**：位置 `(50, 50)`，尺寸 `200x100`，高度为 `1`。
- **鼠标图层**：初始位置 `(100, 100)`，尺寸 `16x16`，高度为 `2`（顶层）。

当鼠标从 `(100, 100)` 移动到 `(120, 120)`，覆盖窗口时，系统按以下步骤刷新：

---

### **1. 旧位置擦除（100, 100）**
#### **步骤 1.1：确定旧区域**
- **旧位置区域**：`(100, 100)` 到 `(116, 116)`。
- **与窗口的交集**：  
  窗口位置 `(50,50)` 到 `(250,150)`，因此旧鼠标区域 `(100,100)-(116,116)` 完全在窗口内。

#### **步骤 1.2：更新映射表 (`sheet_refreshmap`)**
- **作用**：标记旧区域像素的归属。
- **逻辑**：
  ```c
  for (图层从底层到顶层) {
      if (像素非透明) {
          map[位置] = 当前图层ID;
      }
  }
  ```
- **结果**：旧区域的 `map` 会标记为窗口图层（因为鼠标已移走，窗口成为顶层）。

#### **步骤 1.3：重绘旧区域 (`sheet_refreshsub`)**
- **作用**：根据 `map` 重新绘制旧区域。
- **逻辑**：
  ```c
  for (图层从底层到当前图层高度-1) {
      if (map[位置] == 图层ID) {
          显存[位置] = 图层缓冲区[位置];
      }
  }
  ```
- **结果**：旧区域的显存恢复为窗口内容。

---

### **2. 新位置绘制（120, 120）**
#### **步骤 2.1：确定新区域**
- **新位置区域**：`(120, 120)` 到 `(136, 136)`。
- **与窗口的交集**：  
  新区域部分覆盖窗口（窗口范围 `(50,50)-(250,150)`，新鼠标区域 `(120,120)-(136,136)` 完全在窗口内。

#### **步骤 2.2：更新映射表 (`sheet_refreshmap`)**
- **作用**：标记新区域像素的归属。
- **逻辑**：
  ```c
  for (图层从当前图层高度到顶层) { // 仅处理鼠标及其上层（此处无上层）
      if (像素非透明) {
          map[位置] = 鼠标图层ID;
      }
  }
  ```
- **结果**：新区域的 `map` 标记为鼠标图层。

#### **步骤 2.3：重绘新区域 (`sheet_refreshsub`)**
- **作用**：根据 `map` 绘制新区域。
- **逻辑**：
  ```c
  for (图层从当前图层高度到顶层) {
      if (map[位置] == 图层ID) {
          显存[位置] = 图层缓冲区[位置];
      }
  }
  ```
- **结果**：新区域的显存更新为鼠标图案（透明部分保留窗口内容）。

---

### **3. 关键计算：如何确定需要刷新的区域**
#### **公式：屏幕坐标与图层坐标的转换**
- **屏幕坐标 `(vx, vy)`**：显存中的像素位置。
- **图层坐标 `(bx, by)`**：图层缓冲区内的像素位置。
  

当鼠标位于 `(vx0, vy0)` 时：
- **转换关系**：  
  ```c
  bx = vx - sht_mouse->vx0; // 当前鼠标图层坐标
  by = vy - sht_mouse->vy0;
  ```

#### **交集区域计算**
- **旧位置与窗口的交集**：  
  旧鼠标区域：`(100,100)-(116,116)`  
  窗口区域：`(50,50)-(250,150)`  
  交集区域：`(100,100)-(116,116)`（完全在窗口内）。

- **新位置与窗口的交集**：  
  新鼠标区域：`(120,120)-(136,136)`  
  窗口区域：`(50,50)-(250,150)`  
  交集区域：`(120,120)-(136,136)`（完全在窗口内）。

---

### **4. 显存更新优化**
- **透明色处理**：  
  鼠标缓冲区中透明色（如 `col_inv = 99`）的像素不更新显存。
  ```c
  if (buf_mouse[by * 16 + bx] != 99) {
      vram[vy * 320 + vx] = buf_mouse[by * 16 + bx];
  }
  ```

- **局部刷新范围**：  
  仅处理鼠标移动前后的 16x16 区域，而非全屏刷新（节省 320x200 - 2x16x16 = 63,488 次像素计算）。

---

### **总结：鼠标移动时的刷新链**
1. **擦除旧位置**：恢复窗口内容。  
2. **绘制新位置**：显示鼠标图案（跳过透明像素）。  
3. **仅刷新重叠区域**：计算新旧位置与窗口的交集，避免无效绘制。

这种设计通过局部刷新和映射表优化，显著减少了显存操作的计算量。

