
### **具体示例：鼠标移动到窗口上的刷新计算过程**
我们通过一个具体场景，详细拆解背景、窗口、鼠标三个图层的刷新逻辑。假设：

- **屏幕分辨率**：320x240
- **背景图层**：全屏，位置 `(0, 0)`，高度 `0`
- **窗口图层**：位置 `(50, 50)`，尺寸 `200x100`，高度 `1`
- **鼠标图层**：初始位置 `(100, 100)`，尺寸 `16x16`，高度 `2`（顶层）
- **鼠标移动**：从 `(100, 100)` 移动到 `(120, 120)`，覆盖窗口区域

### **1. 旧位置擦除（100, 100 → 116, 116）**
#### **步骤1：确定需要刷新的屏幕区域**
- **旧鼠标区域**：`vx0=100, vy0=100, vx1=116, vy1=116`
- **窗口区域**：`vx0=50, vy0=50, vx1=250, vy1=150`
- **交集区域**：`100 ≤ x < 116, 100 ≤ y < 116`（完全在窗口内）

#### **步骤2：屏幕范围修正**
```c
// 确保不超出屏幕边界（此处无需修正）
vx0 = 100, vy0 = 100, vx1 = 116, vy1 = 116
```

#### **步骤3：遍历图层（从底到顶）**
1. **背景图层**（高度0）：
   - **局部坐标转换**：
     ```c
     bx0 = 100 - 0 = 100 → 超出背景尺寸（320x240）→ bx0=100 (未超出)
     by0 = 100 - 0 = 100 → by0=100 (未超出)
     bx1 = 116 - 0 = 116 → bx1=116 (未超出)
     by1 = 116 - 0 = 116 → by1=116 (未超出)
     ```
   - **实际处理**：背景在该区域没有覆盖窗口，无需处理。
   
2. **窗口图层**（高度1）：
   - **局部坐标转换**：
     ```c
     bx0 = 100 - 50 = 50 → 未超出窗口左边界（0）
     by0 = 100 - 50 = 50 → 未超出窗口上边界（0）
     bx1 = 116 - 50 = 66 → 未超出窗口宽度（200）
     by1 = 116 - 50 = 66 → 未超出窗口高度（100）
     ```
   - **逐像素写入显存**：
     ```c
     for (by = 50; by < 66; by++) {
         vy = 50 + by; // 屏幕y坐标：100~116
         for (bx = 50; bx < 66; bx++) {
             vx = 50 + bx; // 屏幕x坐标：100~116
             c = 窗口缓冲区[by * 200 + bx];
             if (c != 窗口透明色) {
                 vram[vy * 320 + vx] = c; // 恢复窗口内容
             }
         }
     }
     ```

3. **鼠标图层**（高度2）：
   - **局部坐标转换**：
     ```c
     bx0 = 100 - 100 = 0 → 未超出鼠标左边界（0）
     by0 = 100 - 100 = 0 → 未超出鼠标上边界（0）
     bx1 = 116 - 100 = 16 → 未超出鼠标尺寸（16x16）
     by1 = 116 - 100 = 16 → 未超出鼠标尺寸（16x16）
     ```
   - **无需处理**：旧位置的鼠标已移走，由下层图层覆盖。

---

### **2. 新位置绘制（120, 120 → 136, 136）**
#### **步骤1：确定需要刷新的屏幕区域**
- **新鼠标区域**：`vx0=120, vy0=120, vx1=136, vy1=136`
- **窗口区域**：`vx0=50, vy0=50, vx1=250, vy1=150`
- **交集区域**：`120 ≤ x < 136, 120 ≤ y < 136`（完全在窗口内）

#### **步骤2：屏幕范围修正**
```c
vx0=120, vy0=120, vx1=136, vy1=136 // 无需修正
```

#### **步骤3：遍历图层（从底到顶）**
1. **背景图层**（高度0）：
   - **局部坐标转换**：
     ```c
     bx0 = 120 - 0 = 120 → 未超出背景宽度（320）
     by0 = 120 - 0 = 120 → 未超出背景高度（240）
     bx1 = 136 - 0 = 136 → 未超出
     by1 = 136 - 0 = 136 → 未超出
     ```
   - **实际处理**：新区域被窗口和鼠标覆盖，无需处理。

2. **窗口图层**（高度1）：
   - **局部坐标转换**：
     ```c
     bx0 = 120 - 50 = 70 → 未超出窗口宽度（200）
     by0 = 120 - 50 = 70 → 未超出窗口高度（100）
     bx1 = 136 - 50 = 86 → 未超出
     by1 = 136 - 50 = 86 → 未超出
     ```
   - **实际处理**：窗口内容被鼠标覆盖，但需要写入非透明部分。

3. **鼠标图层**（高度2）：
   - **局部坐标转换**：
     ```c
     bx0 = 120 - 120 = 0 → 未超出鼠标左边界
     by0 = 120 - 120 = 0 → 未超出鼠标上边界
     bx1 = 136 - 120 = 16 → 未超出鼠标尺寸
     by1 = 136 - 120 = 16 → 未超出鼠标尺寸
     ```
   - **逐像素写入显存**：
     ```c
     for (by = 0; by < 16; by++) {
         vy = 120 + by; // 屏幕y坐标：120~136
         for (bx = 0; bx < 16; bx++) {
             vx = 120 + bx; // 屏幕x坐标：120~136
             c = 鼠标缓冲区[by * 16 + bx];
             if (c != 鼠标透明色) {
                 vram[vy * 320 + vx] = c; // 绘制鼠标
             }
         }
     }
     ```

---

### **关键计算总结**
1. - **坐标转换公式**：
     
     - **屏幕坐标 → 图层坐标**：  
       $$
       \begin{aligned}
       bx &= vx_{\text{屏幕}} - vx0_{\text{图层}} \\
       by &= vy_{\text{屏幕}} - vy0_{\text{图层}}
       \end{aligned}
       $$
     
     - **图层坐标 → 屏幕坐标**：  
       $$
       \begin{aligned}
       vx &= vx0_{\text{图层}} + bx_{\text{图层}} \\
       vy &= vy0_{\text{图层}} + by_{\text{图层}}
       \end{aligned}
       $$
   
2. **边界修正规则**：
   - 屏幕范围不能超过物理分辨率（例如 `vx1 > 320` 时设为 `320`）。
   - 图层范围不能超过缓冲区尺寸（例如 `bx1 > 200` 时设为 `200`）。

3. **透明色处理逻辑**：
   - 仅当颜色不等于 `col_inv` 时写入显存。
   - 示例：若鼠标缓冲区中 `(bx=5, by=5)` 的颜色为透明色（例如 `99`），则跳过该像素。

---

### **性能优化设计**
1. **局部刷新**：仅处理新旧鼠标位置的 16x16 区域，而非全屏（320x240=76,800 像素），减少计算量至 2x256=512 像素。
2. **映射表加速**：通过 `map` 记录每个像素的顶层图层，避免逐层检查所有图层。
3. **从底到顶遍历**：确保上层图层覆盖下层，最终显存保留顶层非透明像素。

通过这种方式，系统高效地完成了鼠标移动时的显存更新，确保了视觉连贯性和性能优化。